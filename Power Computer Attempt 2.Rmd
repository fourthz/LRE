# ``Power Computer'' Attempt 2
***************

## 1) Preliminary Code (I hid this section to make the file shorter.)
```{r warning=FALSE, message=FALSE, error=FALSE, echo=FALSE}
#Call PASWR package because it has a sign test function.
library(PASWR)

# The sign test function from PAWSR and other R packages do not output the p-value be default
# The function below modifies the existing sign test function to write out the p-values.
# This only needs to be run once per R session (assuming the R Image is not saved after each session).
gSIGN.test<-function (x, y = NULL, md = 0, alternative = "two.sided", conf.level = 0.95) 
{
    choices <- c("two.sided", "greater", "less")
    alt <- pmatch(alternative, choices)
    alternative <- choices[alt]
    if (length(alternative) > 1 || is.na(alternative)) 
        stop("alternative must be one \"greater\", \"less\", \"two.sided\"")
    if (!missing(md)) 
        if (length(md) != 1 || is.na(md)) 
            stop("median must be a single number")
    if (!missing(conf.level)) 
        if (length(conf.level) != 1 || is.na(conf.level) || conf.level < 
            0 || conf.level > 1) 
            stop("conf.level must be a number between 0 and 1")
    if (is.null(y)) {
        dname <- paste(deparse(substitute(x)))
        x <- sort(x)
        diff <- (x - md)
        n <- length(x)
        nt <- length(x) - sum(diff == 0)
        s <- sum(diff > 0)
        estimate <- median(x)
        method <- c("One-sample Sign-Test")
        names(estimate) <- c("median of x")
        names(md) <- "median"
        names(s) <- "s"
        CIS <- "Conf Intervals"
        if (alternative == "less") {
            pval <- sum(dbinom(0:s, nt, 0.5))
            loc <- c(0:n)
            prov <- (dbinom(loc, n, 0.5))
            k <- loc[cumsum(prov) > (1 - conf.level)][1]
            if (k < 1) {
                conf.level <- (1 - (sum(dbinom(k, n, 0.5))))
                xl <- -Inf
                xu <- x[n]
                ici <- c(xl, xu)
            }
            else {
                ci1 <- c(-Inf, x[n - k + 1])
                acl1 <- (1 - (sum(dbinom(0:k - 1, n, 0.5))))
                ci2 <- c(-Inf, x[n - k])
                acl2 <- (1 - (sum(dbinom(0:k, n, 0.5))))
                xl <- -Inf
                xu <- (((x[n - k + 1] - x[n - k]) * (conf.level - 
                  acl2))/(acl1 - acl2)) + x[n - k]
                ici <- c(xl, xu)
            }
        }
        else if (alternative == "greater") {
            pval <- (1 - sum(dbinom(0:s - 1, nt, 0.5)))
            loc <- c(0:n)
            prov <- (dbinom(loc, n, 0.5))
            k <- loc[cumsum(prov) > (1 - conf.level)][1]
            if (k < 1) {
                conf.level <- (1 - (sum(dbinom(k, n, 0.5))))
                xl <- x[1]
                xu <- Inf
                ici <- c(xl, xu)
            }
            else {
                ci1 <- c(x[k], Inf)
                acl1 <- (1 - (sum(dbinom(0:k - 1, n, 0.5))))
                ci2 <- c(x[k + 1], Inf)
                acl2 <- (1 - (sum(dbinom(0:k, n, 0.5))))
                xl <- (((x[k] - x[k + 1]) * (conf.level - acl2))/(acl1 - 
                  acl2)) + x[k + 1]
                xu <- Inf
                ici <- c(xl, xu)
            }
        }
        else {
            p1 <- sum(dbinom(0:s, nt, 0.5))
            p2 <- (1 - sum(dbinom(0:s - 1, nt, 0.5)))
            pval <- min(2 * p1, 2 * p2, 1)
            loc <- c(0:n)
            prov <- (dbinom(loc, n, 0.5))
            k <- loc[cumsum(prov) > (1 - conf.level)/2][1]
            if (k < 1) {
                conf.level <- (1 - 2 * (sum(dbinom(k, n, 0.5))))
                xl <- x[1]
                xu <- x[n]
                ici <- c(xl, xu)
            }
            else {
                ci1 <- c(x[k], x[n - k + 1])
                acl1 <- (1 - 2 * (sum(dbinom(0:k - 1, n, 0.5))))
                ci2 <- c(x[k + 1], x[n - k])
                acl2 <- (1 - 2 * (sum(dbinom(0:k, n, 0.5))))
                xl <- (((x[k] - x[k + 1]) * (conf.level - acl2))/(acl1 - 
                  acl2)) + x[k + 1]
                xu <- (((x[n - k + 1] - x[n - k]) * (conf.level - 
                  acl2))/(acl1 - acl2)) + x[n - k]
                ici <- c(xl, xu)
            }
        }
    }
    else {
        if (length(x) != length(y)) 
            stop("Length of x must equal length of y")
        xy <- sort(x - y)
        diff <- (xy - md)
        n <- length(xy)
        nt <- length(xy) - sum(diff == 0)
        s <- sum(diff > 0)
        dname <- paste(deparse(substitute(x)), " and ", deparse(substitute(y)), 
            sep = "")
        estimate <- median(xy)
        method <- c("Dependent-samples Sign-Test")
        names(estimate) <- c("median of x-y")
        names(md) <- "median difference"
        names(s) <- "S"
        CIS <- "Conf Intervals"
        if (alternative == "less") {
            pval <- sum(dbinom(0:s, nt, 0.5))
            loc <- c(0:n)
            prov <- (dbinom(loc, n, 0.5))
            k <- loc[cumsum(prov) > (1 - conf.level)][1]
            if (k < 1) {
                conf.level <- (1 - (sum(dbinom(k, n, 0.5))))
                xl <- -Inf
                xu <- xy[n]
                ici <- c(xl, xu)
            }
            else {
                ci1 <- c(-Inf, xy[n - k + 1])
                acl1 <- (1 - (sum(dbinom(0:k - 1, n, 0.5))))
                ci2 <- c(-Inf, xy[n - k])
                acl2 <- (1 - (sum(dbinom(0:k, n, 0.5))))
                xl <- -Inf
                xu <- (((xy[n - k + 1] - xy[n - k]) * (conf.level - 
                  acl2))/(acl1 - acl2)) + xy[n - k]
                ici <- c(xl, xu)
            }
        }
        else if (alternative == "greater") {
            pval <- (1 - sum(dbinom(0:s - 1, nt, 0.5)))
            loc <- c(0:n)
            prov <- (dbinom(loc, n, 0.5))
            k <- loc[cumsum(prov) > (1 - conf.level)][1]
            if (k < 1) {
                conf.level <- (1 - (sum(dbinom(k, n, 0.5))))
                xl <- xy[1]
                xu <- Inf
                ici <- c(xl, xu)
            }
            else {
                ci1 <- c(xy[k], Inf)
                acl1 <- (1 - (sum(dbinom(0:k - 1, n, 0.5))))
                ci2 <- c(xy[k + 1], Inf)
                acl2 <- (1 - (sum(dbinom(0:k, n, 0.5))))
                xl <- (((xy[k] - xy[k + 1]) * (conf.level - acl2))/(acl1 - 
                  acl2)) + xy[k + 1]
                xu <- Inf
                ici <- c(xl, xu)
            }
        }
        else {
            p1 <- sum(dbinom(0:s, nt, 0.5))
            p2 <- (1 - sum(dbinom(0:s - 1, nt, 0.5)))
            pval <- min(2 * p1, 2 * p2, 1)
            loc <- c(0:n)
            prov <- (dbinom(loc, n, 0.5))
            k <- loc[cumsum(prov) > (1 - conf.level)/2][1]
            if (k < 1) {
                conf.level <- (1 - 2 * (sum(dbinom(k, n, 0.5))))
                xl <- xy[1]
                xu <- xy[n]
                ici <- c(xl, xu)
            }
            else {
                ci1 <- c(xy[k], xy[n - k + 1])
                acl1 <- (1 - 2 * (sum(dbinom(0:k - 1, n, 0.5))))
                ci2 <- c(xy[k + 1], xy[n - k])
                acl2 <- (1 - 2 * (sum(dbinom(0:k, n, 0.5))))
                xl <- (((xy[k] - xy[k + 1]) * (conf.level - acl2))/(acl1 - 
                  acl2)) + xy[k + 1]
                xu <- (((xy[n - k + 1] - xy[n - k]) * (conf.level - 
                  acl2))/(acl1 - acl2)) + xy[n - k]
                ici <- c(xl, xu)
            }
        }
    }
    if (k < 1) {
        cint <- ici
        attr(cint, "conf.level") <- conf.level
        rval <- structure(list(statistic = s, p.value = pval, 
            estimate = estimate, null.value = md, alternative = alternative, 
            method = method, data.name = dname, conf.int = cint))
        oldClass(rval) <- "htest"
        return(rval)
    }
    else {
        result1 <- c(acl2, ci2)
        result2 <- c(conf.level, ici)
        result3 <- c(acl1, ci1)
        Confidence.Intervals <- round(as.matrix(rbind(result1, 
            result2, result3)), 4)
        cnames <- c("Conf.Level", "L.E.pt", "U.E.pt")
        rnames <- c("Lower Achieved CI", "Interpolated CI", "Upper Achieved CI")
        dimnames(Confidence.Intervals) <- list(rnames, cnames)
        cint <- ici
        attr(cint, "conf.level") <- conf.level
        rval <- structure(list(statistic = s, parameter = NULL, 
            p.value = pval, conf.int = cint, estimate = estimate, 
            null.value = md, alternative = alternative, method = method, 
            data.name = dname))
        oldClass(rval) <- "htest"
rval$Confidence.Intervals <- Confidence.Intervals
return(rval)
    }
}
```

## 2) Complete 100,000 draws of n=10, d=.8, and alpha=.05

```{r}
#Test A

Adraws <- 100000
An1 <- 10
TypeI <-.05
#n2 <- 10
mu <- .8
#mu2 <- 1
sigma <- 1
#sigma2 <- sqrt(1/12)
samp <- matrix(rnorm(An1 * Adraws, mu, sigma), byrow = Adraws, ncol = An1)

Apvals <- rep(0, Adraws)
for (i in 1:Adraws) {Apvals[i] <- t.test(samp[i, ], mu=0, alternative = "two.sided")$p.value}
Apower <- sum(Apvals < TypeI)/Adraws
Apower

#Test B
Bdraws <- 100000
Bn1 <- 10
TypeI <-.05
#n2 <- 10
mu <- .8
#mu2 <- 1
sigma <- 1
#sigma2 <- sqrt(1/12)
samp <- matrix(rnorm(Bn1 * Bdraws, mu, sigma), byrow = Bdraws, ncol = Bn1)

Bpvals <- rep(0, Bdraws)
for (i in 1:Bdraws) {Bpvals[i] <- gSIGN.test(samp[i, ], md = 0, alternative = "two.sided", conf.level = 0.95)$p.value}
Bpower <- sum(Bpvals < TypeI)/Bdraws
Bpower

```

## 3) Make it a function
```{r}
onesam.power<-function(test, n, mu, sigma, draws){
  draws <- draws
  n <- n
  mu <- mu
  sigma <- sigma
  samp <- matrix(rnorm(n * draws, mu, sigma), byrow = draws, ncol = n)
  if(test=="sign"){
    p.vals<-apply(samp, 1, function(x)
      gSIGN.test(x, md = 0, alternative = "two.sided", conf.level = 0.95)$p.value)
    power <- sum(p.vals < .05)/draws
  return(power)
    }
  if(test=="t"){
    p.vals<-apply(samp, 1, function(x)
      t.test(x, mu=0, alternative = "two.sided")$p.value)
    power <- sum(p.vals < .05)/draws
  return(power)}
}  

# This should match very closely to the output above.
onesam.power(test="t", n=10, mu=.8, sigma=1, draws=100000)
# This should match very closely to the output above.
onesam.power(test="sign", n=10, mu=.8, sigma=1, draws=100000)

```

## 4) Make it a function that will work across incrementally increasing sample sizes.
This is a test of sample sizes 10 through 15.
```{r}
test.powerA<-matrix(sapply(10:15, function(x) onesam.power(test="t", n=x, mu=.8, sigma=1, draws=1000)), ncol=1)
test.powerB<-matrix(sapply(10:15, function(x) onesam.power(test="sign", n=x, mu=.8, sigma=1, draws=1000)), ncol=1)
test.power<-rbind(test.powerA, test.powerB)
colnames(test.power)<-c("Power")
```

## 5) Make a simple graph even though we don't need it right now.
```{r}
test.power<-cbind(test.power, 10:15, c(rep("t",6),rep("sign",6)))
colnames(test.power)<-c("Power", "Sample_Size", "Test")
power.plot<-as.data.frame(test.power)
library(ggplot2)
ggplot(data=power.plot, aes(x=Sample_Size, y=Power, group=Test, colour=Test)) +
    geom_line() +
    geom_point()
```

## 6) Trying using lavaan to generate nonnormal data
```{r eval=FALSE}
library(lavaan)
pop.model<-'
  Y~~1*Y
'
samp<-simulateData(pop.model, sample.nobs=150, skewness=1, kurtosis=3)

library(simsem)
samp<-bindDist(skewness=c(0,-2,2), kurtosis=c(0,8,4))
```